<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>oldmantaiter</title><link href="http://oldmantaiter.github.io/" rel="alternate"></link><link href="http://oldmantaiter.github.io/feeds/all.atom.xml" rel="self"></link><id>http://oldmantaiter.github.io/</id><updated>2015-02-23T16:08:00-05:00</updated><entry><title>kdump/kexec with AACRAID</title><link href="http://oldmantaiter.github.io/techlog/2015/02/kdumpkexec-with-aacraid.html" rel="alternate"></link><updated>2015-02-23T16:08:00-05:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2015-02-23:techlog/2015/02/kdumpkexec-with-aacraid.html</id><summary type="html">&lt;p&gt;Back in November we started testing Spark on CentOS 7 and had run into a nasty issue where our nodes would appear to reboot and leave no core dump in /var/crash. This initially led me to believe
that there might have been an issue involving hardware incompatibility or a power issue, it was the first time we had that combination of motherboard and CPU. We have also had a ton of issues with the Adaptec 7 series cards
and them ejecting drives from the array under heavy I/O (a neat feature really), and sometimes the card hanging as well under high I/O. Strangely enough
for that issue we found that disabling the write caching (specifically in front of SSDs) would stop the ejection of the drive. Still, not a great situation.&lt;/p&gt;
&lt;p&gt;With all that information I approached the issue with a misguided idea of thinking it was a firmware issue - not without some well deserved doubts about the Adaptec controller from previous experiences. I updated
the aacraid kernel module to the latest available, the controller firmware, the BIOS even and it appeared to be going well for a little while... then the crashes returned.&lt;/p&gt;
&lt;p&gt;So at this point, I'm thinking its definitely not a RAID card issue. I remembered another CentOS 7 testing box had rebooted a week or two prior when under a light/medium workload. Maybe it could
shed some light on the situation, if it captured a core dump. And sure enough it did (it had no RAID card), and there even was an upstream kernel fix for that issue (&lt;a class="reference external" href="https://github.com/torvalds/linux/commit/e15693ef18e13e3e6bffe891fe140f18b8ff6d07?diff=unified"&gt;cfq-iosched: Fix wrong children_weight calculation&lt;/a&gt;).
It appeared as though my investigation had come to a close, so I backported the fix to the latest CentOS 7 kernel that was available and asked everyone testing the cluster by shoving as many jobs down its throat as possible - the cluster smiled happily
for a few hours so I went for a coffee, and then... more failures.&lt;/p&gt;
&lt;p&gt;Finally, I decided to start looking into the aacraid module and kdump.
I added aacraid to the extra_modules section in /etc/kdump.conf and added the root disk's UUID for good measure, then issued a panic hoping that the issue might have been a simple misconfiguration of kdump (something I should have tried from the beginning),
alas it could not find the disk (and RAID controller) so I set it to default to a shell and tried again.
Once in the shell I checked dmesg for aacraid messages, the driver loads but there is no output from the driver saying it found drives or a controller for that matter, and eventually fails after a long timeout with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;AAC0: adapter kernel failed to start, init status = 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was time to start digging deeper, I looked through the changelogs for the EL7 kernel for anything involving the aacraid module. Turns out there have been multiple patches and bugfixes over the past couple years for aacraid not playing well with
the reset_devices boot flag. At this point I thought &amp;quot;What the hell, why not just remove it and see what happens&amp;quot;,
I removed the reset_devices from the KDUMP_COMMANDLINE_APPEND variable in /etc/sysconfig/kdump, restarted the kdump service (which rebuilt the boot image), and issued another panic.&lt;/p&gt;
&lt;p&gt;This time.... SUCCESS! The drive was mounted and the dump began.&lt;/p&gt;
&lt;p&gt;After all that extra work I gave myself (through misdiagnosis), it was the removal of 13 characters from one file that will enable me to see what is causing this box to panic - and almost forced us back to using CentOS 6.&lt;/p&gt;
&lt;p&gt;As an aside, the issue really is with these RAID cards. After much more investigation and a ton of late nights with Pagerduty and I becoming the best of friends, we were getting nowhere. The RAID card would not only eject drives but actually become unavailable and bring the entire box down.&lt;/p&gt;
&lt;p&gt;We reprovisioned with LSI cards and the nodes haven't had an issue since.&lt;/p&gt;
</summary><category term="aacraid"></category><category term="centos7"></category><category term="el7"></category><category term="rhel7"></category></entry><entry><title>Disco - A Powerful Erlang and Python Map/Reduce Framework</title><link href="http://oldmantaiter.github.io/techlog/2014/05/disco-a-powerful-erlang-and-python-mapreduce-framework.html" rel="alternate"></link><updated>2014-05-05T15:36:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2014-05-05:techlog/2014/05/disco-a-powerful-erlang-and-python-mapreduce-framework.html</id><summary type="html">&lt;p&gt;In the wake of &lt;a class="reference external" href="http://www.pydata.org"&gt;PyData 2014&lt;/a&gt; I felt it was important to share my thoughts on the power of &lt;a class="reference external" href="http://www.discoproject.org"&gt;Disco&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For those of you who may not know what Disco (also know as the Disco Project) can do and why it is so powerful, it's core is written in Erlang and the workers for job parts run Python (more languages coming).
This means that running anything from regular aggregation/exploration jobs to machine learning using the great libraries and quick prototyping available with Python.&lt;/p&gt;
&lt;p&gt;When comparing Disco to Hadoop, which I hope to do in detail in the very near future, it is important to note the simplicity of Disco. It uses the concurrency and clustering of Erlang so you don't
require anything other than one master server to submit jobs and push files into the Disco Distributed File System (DDFS).
This also means that there is virtually no latency when starting jobs and getting up and running quickly; a requirement for the distributed, relational event database that &lt;a class="reference external" href="http://www.chango.com"&gt;Chango&lt;/a&gt;
has open sourced called &lt;a class="reference external" href="https://github.com/chango/hustle"&gt;Hustle&lt;/a&gt; that
I won't be going into great detail in this particular post, but it is definitely worth taking a look and reading about how it works.&lt;/p&gt;
&lt;p&gt;Another advantage of Disco is that you can run a single node cluster on your local laptop (I run it on a MacBook Air) to test jobs and push data into DDFS; it has almost zero overhead and you don't
need to run it in a virtual machine and download a distro like Cloudera and fuss around with XML (which is a massive plus in my opinion).&lt;/p&gt;
&lt;p&gt;Not only does Disco allow you to run regular MapReduce jobs, but you can use pipelines starting from version 0.5.x. &lt;a class="reference external" href="http://disco.readthedocs.org/en/latest/howto/pipeline.html"&gt;Pipelines&lt;/a&gt; are extremely powerful,
defined as a linear sequence of stages, where the outputs of each stage are grouped into the input of the subsequent stage.&lt;/p&gt;
&lt;p&gt;At &lt;a class="reference external" href="http://www.chango.com"&gt;Chango&lt;/a&gt; we use Disco as our data crunching powerhouse, ploughing through our massive amounts of data with ease and allowing our data scientists to quickly prototype and isolate subsets
of data to run machine learning algorithms.&lt;/p&gt;
&lt;p&gt;I will be following this post, which is really an introduction to Disco, with some examples and some deeper concepts of running pipelines.&lt;/p&gt;
&lt;p&gt;Futhermore, I am going to assist in easier packaging and bundling of Disco (including test data sets), maybe with an iPython Notebook, to help those who may not be entirely familiar with python and map reduce
concepts the ability to explore.&lt;/p&gt;
&lt;p&gt;The Disco community is growing, and if you are interested I highly suggest joining in and trying it out for your workloads. I will release more information about the packaging (most likely using &lt;a class="reference external" href="http://conda.pydata.org/"&gt;Conda&lt;/a&gt;)
and iPython Notebook as I get more time to develop it.&lt;/p&gt;
&lt;div class="section" id="links"&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://groups.google.com/forum/#!forum/disco-dev"&gt;Disco Mailing List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/discoproject/disco"&gt;Disco on Github&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</summary><category term="discoproject"></category><category term="disco"></category><category term="pipeline"></category><category term="map-reduce"></category><category term="bigdata"></category><category term="hustle"></category><category term="erlang"></category><category term="python"></category></entry><entry><title>Heading to PyData</title><link href="http://oldmantaiter.github.io/techlog/2014/05/heading-to-pydata.html" rel="alternate"></link><updated>2014-05-01T09:36:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2014-05-01:techlog/2014/05/heading-to-pydata.html</id><summary type="html">&lt;p&gt;So I am one of the lucky few from the Engineering team &amp;#64; &lt;a class="reference external" href="http://www.chango.com"&gt;Chango&lt;/a&gt; chosen to go and check out &lt;a class="reference external" href="http://pydata.org/sv2014"&gt;PyData&lt;/a&gt; down
in San Francisco!&lt;/p&gt;
&lt;p&gt;Our lead large scale data architect/senior VP of dealing with epic amounts of data &lt;a class="reference external" href="https://twitter.com/t1m"&gt;Tim Spurway (&amp;#64;t1m)&lt;/a&gt; will be giving a talk on &lt;a class="reference external" href="https://github.com/chango/hustle"&gt;Hustle&lt;/a&gt;
tomorrow, so if you are headed down I highly recommend sitting in and watching this column oriented database plough through massive data sets with speed and ease.&lt;/p&gt;
&lt;p&gt;Time to get in line at the airport, but really excited for my first visit to California!&lt;/p&gt;
</summary><category term="announcement"></category></entry><entry><title>Posts Incoming</title><link href="http://oldmantaiter.github.io/techlog/2014/04/posts-incoming.html" rel="alternate"></link><updated>2014-04-25T18:52:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2014-04-25:techlog/2014/04/posts-incoming.html</id><summary type="html">&lt;p&gt;Well, it is time for me to embrace github and stop using a hosted environment for my tiny tech blog.&lt;/p&gt;
&lt;p&gt;Over the coming days I will be porting the necessary things over and adding new thoughts and ideas.&lt;/p&gt;
</summary><category term="announcement"></category></entry><entry><title>FTP Load-Balanced through haproxy</title><link href="http://oldmantaiter.github.io/techlog/2012/09/ftp-load-balanced-through-haproxy.html" rel="alternate"></link><updated>2012-09-14T11:47:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2012-09-14:techlog/2012/09/ftp-load-balanced-through-haproxy.html</id><summary type="html">&lt;p&gt;I was asked to explore the possibility of having haproxy balance connections between multiple backend FTP servers. Luckily there is a way to do this without having to play with DNAT on the proxy server and instead setting it up with multiple backends in haproxy.&lt;/p&gt;
&lt;p&gt;First you will need to setup a few FTP servers. I chose VSFTP (which can be installed on CentOS via &amp;quot;yum install vsftpd&amp;quot;)&lt;/p&gt;
&lt;p&gt;As far as I know, this will only work properly with ftp passive mode. For that you can make the following vsftpd config&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[tait@foxtrot-tango-papa01 ~]$&lt;/span&gt; cat /etc/vsftpd/vsftpd.conf
&lt;span class="go"&gt;anonymous_enable=NO&lt;/span&gt;
&lt;span class="go"&gt;local_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;write_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;local_umask=022&lt;/span&gt;
&lt;span class="go"&gt;dirmessage_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;xferlog_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;connect_from_port_20=NO&lt;/span&gt;
&lt;span class="go"&gt;xferlog_file=/var/log/xferlog&lt;/span&gt;
&lt;span class="go"&gt;xferlog_std_format=YES&lt;/span&gt;
&lt;span class="go"&gt;pam_service_name=vsftpd&lt;/span&gt;

&lt;span class="go"&gt;# This is a user whitelist we use&lt;/span&gt;
&lt;span class="go"&gt;userlist_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;userlist_deny=NO&lt;/span&gt;
&lt;span class="go"&gt;userlist_file=/etc/vsftpd/user_list&lt;/span&gt;
&lt;span class="go"&gt;tcp_wrappers=YES&lt;/span&gt;
&lt;span class="go"&gt;pasv_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;pasv_promiscuous=NO&lt;/span&gt;
&lt;span class="go"&gt;port_enable=YES&lt;/span&gt;
&lt;span class="go"&gt;port_promiscious=NO&lt;/span&gt;

&lt;span class="go"&gt;# Added listen address for internal only&lt;/span&gt;
&lt;span class="go"&gt;listen=YES&lt;/span&gt;
&lt;span class="go"&gt;# If you use this method, change the listen_address for each server (duh)&lt;/span&gt;
&lt;span class="go"&gt;listen_address=10.0.0.10&lt;/span&gt;

&lt;span class="go"&gt;# These are the ports to use for PASV mode&lt;/span&gt;
&lt;span class="go"&gt;# It is important that these port numbers are unique across each of your backend servers&lt;/span&gt;
&lt;span class="go"&gt;pasv_min_port=10000&lt;/span&gt;
&lt;span class="go"&gt;pasv_max_port=10250&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So basically for each server you should be creating a new port range to use with passive ftp.
My configuration has the following:&lt;/p&gt;
&lt;p&gt;foxtrot-tango-papa01: 10001 -&amp;gt; 10250
foxtrot-tango-papa02: 10251 -&amp;gt; 10500
foxtrot-tango-papa03: 10501 -&amp;gt; 10750&lt;/p&gt;
&lt;p&gt;Ensure that your configuration works on each node and try sample ftp connections to each of your servers before we proceed to configuring and using haproxy for the frontend.&lt;/p&gt;
&lt;p&gt;Download and install haproxy, you can either do this by source or through a 3rd party repository.&lt;/p&gt;
&lt;p&gt;This is what my config (very basic) looks like.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[tait@ftp-proxy01]$&lt;/span&gt; cat /etc/haproxy/haproxy.cfg
&lt;span class="go"&gt;# HAPROXY Config for FTP&lt;/span&gt;
&lt;span class="go"&gt;# my apologies for the spacing&lt;/span&gt;
&lt;span class="go"&gt;global&lt;/span&gt;
&lt;span class="go"&gt;    log 127.0.0.1 local0 info&lt;/span&gt;
&lt;span class="go"&gt;    chroot /var/lib/haproxy&lt;/span&gt;
&lt;span class="go"&gt;    user haproxy&lt;/span&gt;
&lt;span class="go"&gt;    group haproxy&lt;/span&gt;
&lt;span class="go"&gt;    maxconn 2000&lt;/span&gt;

&lt;span class="go"&gt;defaults&lt;/span&gt;
&lt;span class="go"&gt;    log global&lt;/span&gt;
&lt;span class="go"&gt;    mode tcp&lt;/span&gt;
&lt;span class="go"&gt;    option tcplog&lt;/span&gt;
&lt;span class="go"&gt;    retries 3&lt;/span&gt;

&lt;span class="go"&gt;# This is for the initial connection and control traffic&lt;/span&gt;
&lt;span class="go"&gt;frontend foxtrot-tango-papa-control&lt;/span&gt;
&lt;span class="go"&gt;    bind *:21&lt;/span&gt;
&lt;span class="go"&gt;    default_backend ftp_server_pool&lt;/span&gt;

&lt;span class="go"&gt;# Each of these frontends represent a server and its corresponding PASV ports we set&lt;/span&gt;
&lt;span class="go"&gt;frontend foxtrot-tango-papa01&lt;/span&gt;
&lt;span class="go"&gt;    bind *:10001-10250&lt;/span&gt;
&lt;span class="go"&gt;    default_backend foxtrot_tango_papa01&lt;/span&gt;

&lt;span class="go"&gt;frontend foxtrot-tango-papa02&lt;/span&gt;
&lt;span class="go"&gt;    bind *:10251-10500&lt;/span&gt;
&lt;span class="go"&gt;    default_backend foxtrot_tango_papa02&lt;/span&gt;

&lt;span class="go"&gt;frontend foxtrot-tango-papa03&lt;/span&gt;
&lt;span class="go"&gt;    bind *:10501-10750&lt;/span&gt;
&lt;span class="go"&gt;    default_backend foxtrot_tango_papa03&lt;/span&gt;

&lt;span class="go"&gt;# Global backend for the ftp control traffic to find a server&lt;/span&gt;
&lt;span class="go"&gt;backend ftp_server_pool&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa01 10.0.0.10 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa02 10.0.0.11 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa03 10.0.0.12 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;

&lt;span class="go"&gt;# Backends for each of our FTP servers&lt;/span&gt;
&lt;span class="go"&gt;backend foxtrot_tango_papa01&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa01 10.0.0.10 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;

&lt;span class="go"&gt;backend foxtrot_tango_papa02&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa02 10.0.0.11 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;

&lt;span class="go"&gt;backend foxtrot_tango_papa03&lt;/span&gt;
&lt;span class="go"&gt;    server foxtrot-tango-papa03 10.0.0.12 check port 21 inter 10s rise 1 fall 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you should be able to start haproxy (ignore warnings or take care of them as you need to... like I said, very basic config) and ftp to it.&lt;/p&gt;
&lt;p&gt;Be warned, this configuration makes haproxy bind to EVERY passive port listed, but you should be able to ftp to the haproxy IP and transfer files to and from your FTP server pool.&lt;/p&gt;
&lt;p&gt;Leave a comment if you require any help, but as a basic config this should work.&lt;/p&gt;
</summary><category term="haproxy"></category><category term="ftp"></category></entry><entry><title>OpenIndiana (Solaris) VLAN Trunk</title><link href="http://oldmantaiter.github.io/techlog/2012/03/openindiana-solaris-vlan-trunk.html" rel="alternate"></link><updated>2012-03-22T11:00:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2012-03-22:techlog/2012/03/openindiana-solaris-vlan-trunk.html</id><summary type="html">&lt;p&gt;I recently discovered a need to be able to add multiple VLANs on a single interfaces on Solaris.&lt;/p&gt;
&lt;p&gt;This one is really simple! Just make sure you are running as root, not escalating privileges with pfexec.&lt;/p&gt;
&lt;p&gt;So, lets start this off. Figure out which of your interfaces you want to use as the trunk, in my case it is atge0.
Make sure that you have setup whichever switchport on your switch to be a dot1q trunk&lt;/p&gt;
&lt;p&gt;In this scenario I have my server originally on a switchport just in access mode on VLAN 10. To make it into a trunk (network will drop for around 30 seconds) you can reconfigure the port with the commands below to still be on VLAN 10 if using Cisco.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;taiter-sw# configure terminal&lt;/span&gt;
&lt;span class="go"&gt;Enter configuration commands, one per line. End with CNTL/Z.&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config)# interface gi0/5&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config-if)# switchport&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config-if)# switchport trunk encapsulation dot1q&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config-if)# switchport trunk native vlan 10&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config-if)# switchport mode trunk&lt;/span&gt;
&lt;span class="go"&gt;taiter-sw(config-if)# end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then issue the following commands (substituting your NIC for where I've put atge0):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;root@taiter:~#&lt;/span&gt; dladm create-vnic -l atge0 -v &lt;span class="m"&gt;30&lt;/span&gt; atge0.30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The argument for the VLAN is -v VLANID and then you can call your new virtual interface whatever you like. I tend to like the INTERFACE.VLAN naming.&lt;/p&gt;
&lt;p&gt;Now we can give an IP to the new VNIC.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;root@taiter:~#&lt;/span&gt; ifconfig atge0.30 plumb 10.1.1.5/24 up
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I've just shown an example, but obviously change 10.1.1.5/24 to your IP and mask that is on that VLAN.&lt;/p&gt;
</summary><category term="vlan"></category><category term="networking"></category></entry><entry><title>OpenSIPS Dynamic Routing</title><link href="http://oldmantaiter.github.io/techlog/2012/02/opensips-dynamic-routing.html" rel="alternate"></link><updated>2012-02-09T17:05:00-05:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2012-02-09:techlog/2012/02/opensips-dynamic-routing.html</id><summary type="html">&lt;p&gt;I've been playing with OpenSIPS and Freeswitch recently and was intrigued by the Dynamic Routing [drouting] module for call routing.&lt;/p&gt;
&lt;p&gt;Although I don't have a full grip on all the features that are available in this module, basic functionality is still pretty useful.&lt;/p&gt;
&lt;p&gt;I basically wanted to be able to route specific DIDs to certain Freeswitch servers and have a list of carriers with failover for outbound calls.&lt;/p&gt;
&lt;p&gt;So lets get started, I'm assuming you already have a mysql database setup for opensips and have granted access to it to a user.&lt;/p&gt;
&lt;p&gt;Lets setup the database:&lt;/p&gt;
&lt;p&gt;There are 4 tables involved in dynamic routing:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;dr_groups&lt;/strong&gt;: This is where you call dynamic routing from the configuration files (I will explain later)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dr_gateways&lt;/strong&gt;: These are your route endpoints, so for us it was our freeswitch servers&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dr_gw_lists&lt;/strong&gt;: These are list entries that combine the entries in dr_gateways and allow for failover&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dr_rules&lt;/strong&gt;: In here you put in the rules for inbound DIDs or default routes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To setup the dr_groups I chose to create two separate groups for inbound and outbound calling to help split up the dial plans. Connect to your opensips mysql instance and change to your opensips database.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;use&lt;/span&gt; &lt;span class="n"&gt;opensips&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Reading&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;completion&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="k"&gt;column&lt;/span&gt; &lt;span class="n"&gt;names&lt;/span&gt;
&lt;span class="n"&gt;You&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;turn&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;feature&lt;/span&gt; &lt;span class="k"&gt;to&lt;/span&gt; &lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;quicker&lt;/span&gt; &lt;span class="n"&gt;startup&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;

&lt;span class="k"&gt;Database&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;
&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="nf"&gt;dr_groups&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;domain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;groupid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.*&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;INBOUND&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since it didn't really matter about the domains and usernames, I set them as wildcard values. The important part is the groupid, it is how we are going to call our dynamic routes. I set the description to INBOUND because that is what I am going to do for my inbound calling routes.&lt;/p&gt;
&lt;p&gt;Into the dr_gateways table we can put the gateways that we will use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="nf"&gt;dr_gateways&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;strip&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;probe_mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;GW_IP:PORT&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Freeswitch&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I don't think the type matters right now. And the GW_IP:GW_PORT is the IP of your endpoint, in my case it was the freeswitch. The &amp;quot;strip&amp;quot; column is how many digits you want to strip before passing it on. The &amp;quot;probe_mode&amp;quot; is important if you want failover when using dr_gw_lists. Setting it to 2 enables probing so it will keep a list of which gateways are still active.&lt;/p&gt;
&lt;p&gt;You can decide to setup dr_gw_lists if you would like to.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="nf"&gt;dr_gw_lists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gwlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;DESCRIPTION&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the &amp;quot;gwlist&amp;quot; column you put in the gwid from the gateways you created in the dr_gateways table, in this example I'm using the gwid of 1. You can also reference multiple gateways by comma separating them like VALUES(&amp;quot;4,3&amp;quot;,&amp;quot;DESCRIPTION). That would use gateways with gwid 3 and 4.&lt;/p&gt;
&lt;p&gt;Last we can setup the rules we are going to use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="nf"&gt;dr_rules&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;groupid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;gwlist&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;4165555555&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;My Number&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can see here that the groupid is 0 like we added to dr_groups. The prefix is the number to match, in this case it is a full DID, you can put less or more specific prefixes in there to your liking. For example I could add a default route by leaving the prefix empty or match all 416 numbers by putting the prefix as &amp;quot;416&amp;quot;. It will match the most specific prefix and route accordingly. The &amp;quot;gwlist&amp;quot; column references either the gateway from dr_gateways or the gateway list from dr_gw_lists. My example above uses the gateway with a gwid of 1, to use a gateway list just add a &amp;quot;#&amp;quot; before the id number of the entry from dr_gw_lists.&lt;/p&gt;
&lt;p&gt;Now we can look at changing the opensips configuration files.&lt;/p&gt;
&lt;p&gt;You need to add the following to your /etc/opensips/opensips.cfg file (if they don't already exist):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;loadmodule &amp;quot;drouting.so&amp;quot;&lt;/span&gt;
&lt;span class="go"&gt;loadmodule &amp;quot;db_mysql.so&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now add the drouting module options:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;db_url&amp;quot;, &amp;quot;mysql://DBUSER:DBPASSWD@localhost/DBNAME&amp;quot;)&lt;/span&gt;
&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;probing_interval&amp;quot;, 60)&lt;/span&gt;
&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;probing_from&amp;quot;, &amp;quot;sip:probe@URI&amp;quot;)&lt;/span&gt;
&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;probing_method&amp;quot;, &amp;quot;OPTIONS&amp;quot;)&lt;/span&gt;
&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;probing_reply_codes&amp;quot;, &amp;quot;501, 403, 404&amp;quot;)&lt;/span&gt;
&lt;span class="go"&gt;modparam(&amp;quot;drouting&amp;quot;, &amp;quot;use_domain&amp;quot;, 1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For DBUSER put in the username you gave access to the opensips database, DBPASSWD is the password of that user and DBNAME is the database name. The next items just setup the probing configuration where probing_interval is how often it polls in seconds, probing_from is the URI you send from, probing_method is the call that you will make (different for some types of gateways), and probing_reply_codes are the codes other than a 200 that will be considered valid.&lt;/p&gt;
&lt;p&gt;Since the database is taken care of and populated, it's time to add the dynamic routing entries to your routing config.&lt;/p&gt;
&lt;p&gt;In your main routing block you need to add something similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;if (method == &amp;quot;INVITE&amp;quot;) {&lt;/span&gt;
&lt;span class="go"&gt;                setflag(1);&lt;/span&gt;
&lt;span class="go"&gt;        record_route();&lt;/span&gt;
&lt;span class="go"&gt;                xlog(&amp;quot;INBOUND CALL,$dd,$ru,$ci,$fn,$fu&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;        route(10);&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will call the subroute of 10 when an INVITE is called, so we have to add that too.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;route[10] {&lt;/span&gt;
&lt;span class="go"&gt;    if (!do_routing(&amp;quot;0&amp;quot;)) {&lt;/span&gt;
&lt;span class="go"&gt;        xlog(&amp;quot;do_routing: No rules matching the URI\n&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;        send_reply(&amp;quot;503&amp;quot;,&amp;quot;No rules matching the URI&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;

&lt;span class="go"&gt;    if (is_method(&amp;quot;INVITE&amp;quot;)) {&lt;/span&gt;
&lt;span class="go"&gt;        t_on_failure(&amp;quot;10&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;
&lt;span class="go"&gt;    route(1);&lt;/span&gt;
&lt;span class="go"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is where your dr_groups table entry is important. The do_routing(&amp;quot;0&amp;quot;) is calling the group with the groupid of zero and will lookup any subsequent routes that have 0 as the groupid.&lt;/p&gt;
&lt;p&gt;It also primes a failure route incase it fails, we will need to add this as well.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;failure_route[10] {&lt;/span&gt;
&lt;span class="go"&gt;    xlog(&amp;quot;DEBUG: DROUTING failure route active\n&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;    if (t_was_cancelled()) {&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;
&lt;span class="go"&gt;    if (t_check_status(&amp;quot;[34][0-9][0-9]&amp;quot;)) {&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;

&lt;span class="go"&gt;    if (use_next_gw()) {&lt;/span&gt;
&lt;span class="go"&gt;        t_relay();&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;    } else {&lt;/span&gt;
&lt;span class="go"&gt;    t_reply (&amp;quot;503&amp;quot;, &amp;quot;Service not available&amp;quot;);&lt;/span&gt;
&lt;span class="go"&gt;        exit;&lt;/span&gt;
&lt;span class="go"&gt;    }&lt;/span&gt;
&lt;span class="go"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On failure it will lookup the next gateway in the gw_list (if active) and try and fail the call to that secondary gateway.&lt;/p&gt;
&lt;p&gt;This should be all you need to get started. You can add something very similar to route outbound calls. Where you setup another dr_groups entry, along with all the necessary gateways and rules. Then to differentiate between inbound and outbound calls  you can add another entry to your main routing block that contains:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;if (method == &amp;quot;INVITE&amp;quot; &amp;amp;&amp;amp; src_ip =~ &amp;quot;xxx\.xxx\.xxx.*&amp;quot; ) {&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where xxx.xxx.xxx is a local subnet that your freeswitch would be sending invites from.&lt;/p&gt;
&lt;p&gt;Finally just add another routing block, something like route[20] and set up do_routing to reference your new outbound group from dr_groups.&lt;/p&gt;
&lt;p&gt;Leave a comment if you run into problems. If you've followed other tutorials and it is failing, make sure that in your dr_rules table the routeid isn't set to anything.&lt;/p&gt;
&lt;p&gt;You can check out the dynamic routing module man page here: &lt;a class="reference external" href="http://www.opensips.org/html/docs/modules/devel/drouting.html"&gt;http://www.opensips.org/html/docs/modules/devel/drouting.html&lt;/a&gt;&lt;/p&gt;
</summary><category term="opensips"></category><category term="voip"></category></entry><entry><title>Console Redirection with XEN and Linux for Sun iLOM/IPMI</title><link href="http://oldmantaiter.github.io/techlog/2011/10/console-redirection-with-xen-and-linux-for-sun-ilomipmi.html" rel="alternate"></link><updated>2011-10-07T13:29:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2011-10-07:techlog/2011/10/console-redirection-with-xen-and-linux-for-sun-ilomipmi.html</id><summary type="html">&lt;p&gt;Having a working IPMI/ILOM card is pretty much essential when rolling out a new system to a remote location or lights-out data center. There were some issues in getting the onboard Sun IPMI card on a Sun Fire X4100 (this should work for X4140 X4200 X4600 etc) to print to both the graphical console as well as the serial when using Xen.&lt;/p&gt;
&lt;p&gt;One of the issues is that Xen wants to grab by default ttyS0 which is what the Sun IPMI serial port is and as I understand it, have the wrong serial port settings.&lt;/p&gt;
&lt;p&gt;So here is the configuration to get it working and sending to both the serial and regular system console (VGA, IPMI redirection via web):&lt;/p&gt;
&lt;p&gt;Change /etc/grub.conf to have something similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;title CentOS (xen)&lt;/span&gt;
&lt;span class="go"&gt;     root (hd0,0)&lt;/span&gt;
&lt;span class="go"&gt;       kernel /xen.gz com1=9600,8n1&lt;/span&gt;
&lt;span class="go"&gt;       module /vmlinuz-xen ro root=LABEL=/ console=ttyS0,9600n8 console=tty0&lt;/span&gt;
&lt;span class="go"&gt;       module /initrd-xen.img&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On the Xen kernel line there is one argument:&lt;/p&gt;
&lt;p&gt;com1=9600,8n1 : This is the line to make the Xen console play nice with the Sun. Please note that if your IPMI console is set to another speed you will have to change 9600 to match the speed you are using.&lt;/p&gt;
&lt;p&gt;On the system kernel line there are a few more added arguments:&lt;/p&gt;
&lt;p&gt;console=ttyS0,9600n8 : Adding this will activate the IPMI serial console, remember that if your serial port settings are different you will need to change the 9600n8 part to whatever will match with yours.&lt;/p&gt;
&lt;p&gt;console=tty0 : This just ensures that the output will be redirected to the default console (VGA etc.)&lt;/p&gt;
&lt;p&gt;Edit /etc/inittab and add the below line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;co:2345:respawn:/sbin/agetty ttyS0 9600 vt100-nav&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Add ttyS0 to /etc/securetty&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;ttyS0&amp;quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/securetty
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you should be able to see everything in the serial console via the IPMI as if it were on a monitor infront of you.&lt;/p&gt;
</summary><category term="xen"></category><category term="ipmi"></category><category term="console"></category></entry><entry><title>Rename KVM Virtual Machine with virsh</title><link href="http://oldmantaiter.github.io/techlog/2011/01/rename-kvm-virtual-machine-with-virsh.html" rel="alternate"></link><updated>2011-01-11T11:19:00-05:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2011-01-11:techlog/2011/01/rename-kvm-virtual-machine-with-virsh.html</id><summary type="html">&lt;p&gt;Decided to play around with virsh today to see if I could rename some VMs that changed their hostname and purpose. It's actually quite simple!&lt;/p&gt;
&lt;p&gt;I am using Fedora 14 for this but I assume it will work for Ubuntu and CentOS as well.&lt;/p&gt;
&lt;p&gt;You must have elevated privileges for this to work so either become root or use sudo.&lt;/p&gt;
&lt;p&gt;Power off the virtual machine and export the machine's XML configuration file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; virsh dumpxml name_of_vm &amp;gt; name_of_vm.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, edit the XML file and change the name between the &lt;strong&gt;&amp;lt;name&amp;gt;&amp;lt;/name&amp;gt;&lt;/strong&gt; tags (should be right near the top). As an added step you could also rename the disk file to reflect the change of the name and change the name of it in the &lt;strong&gt;&amp;lt;devices&amp;gt;&lt;/strong&gt; section under &lt;strong&gt;&amp;lt;source file='/path/to/name_of_vm.img'&amp;gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Save the XML file and undefine the old VM name with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; virsh undefine name_of_vm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now just import the edited XML file to define the VM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; virsh define name_of_vm.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that should be it! You can now start up your vm either in the Virtual Machine Manager or with virsh using:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; virsh start name_of_vm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hope this was helpful!&lt;/p&gt;
</summary><category term="kvm"></category><category term="virsh"></category></entry><entry><title>nVIDIA GT210 - HDMI Audio</title><link href="http://oldmantaiter.github.io/techlog/2010/07/nvidia-gt210-hdmi-audio.html" rel="alternate"></link><updated>2010-07-16T12:24:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2010-07-16:techlog/2010/07/nvidia-gt210-hdmi-audio.html</id><summary type="html">&lt;p&gt;Recently my Shuttle HTPC started having issues when booting into Gnome using any sort of hardware video acceleration. I would turn it on and watch it boot until it got to the login screen, at this point it would either let me login and then power off or just power off before it got to the graphical login screen.&lt;/p&gt;
&lt;p&gt;I decided to pick up a new video card with HDMI so I wouldn't have to switch my speaker input to direct each time I wanted to use my PC. I grabbed the EVGA GeForce 210 from Tiger Direct and after some power setting changes in the BIOS, the computer booted and automatically started using the newly plugged in HDMI cable!&lt;/p&gt;
&lt;p&gt;Now all I had to do was get the sound working.
To get sound output, I first needed to turn off the onboard HD audio from the BIOS because it is also made by nVIDIA and will cause problems when trying to get the sound going.&lt;/p&gt;
&lt;p&gt;Next I found a great thread (&lt;a class="reference external" href="http://forum.xbmc.org/showthread.php?t=69601"&gt;http://forum.xbmc.org/showthread.php?t=69601&lt;/a&gt;) for XBMC and how to setup HDMI audio. Their config sort of worked for me but I had to change a few things.&lt;/p&gt;
&lt;p&gt;Please note that this is for Fedora.&lt;/p&gt;
&lt;p&gt;First I noticed that the prerequisites for their version required alsa 1.0.23 drivers. Fedora only had 1.0.21 by default so I needed to grab packages from ATrpms.&lt;/p&gt;
&lt;p&gt;I added the repo for yum as follows:&lt;/p&gt;
&lt;p&gt;Create the file &lt;strong&gt;/etc/yum.repos.d/atrpms.repo&lt;/strong&gt; with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;[atrpms]&lt;/span&gt;
&lt;span class="go"&gt;name=Fedora Core $releasever - $basearch - ATrpms&lt;/span&gt;
&lt;span class="go"&gt;baseurl=http://dl.atrpms.net/f$releasever-$basearch/atrpms/stable&lt;/span&gt;
&lt;span class="go"&gt;gpgkey=http://atrpms.net/RPM-GPG-KEY.atrpms&lt;/span&gt;
&lt;span class="go"&gt;gpgcheck=1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then you can run&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; yum install alsa-driver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install any dependencies that are required.&lt;/p&gt;
&lt;p&gt;Next you need to configure the hd sound module to work properly. As it stands right now, your machine will probably tell you that it has 4 SPDIF outputs for the card, this will not work so we have to change it.&lt;/p&gt;
&lt;p&gt;Create the file &lt;strong&gt;/etc/modprobe.d/sound.conf&lt;/strong&gt; with the following contents:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;options snd-hda-intel enable_msi=0 probe_mask=0xfff2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now reboot your machine, a quick look at &lt;strong&gt;/proc/asound/version&lt;/strong&gt; should show that the drivers are now at 1.0.23.&lt;/p&gt;
&lt;p&gt;At this point you should have some sound, but if you don't fire up alsamixer and change the soundcard  to the nVIDIA card and see if the line is muted. If it is muted, just press &amp;quot;m&amp;quot; to unmute.&lt;/p&gt;
&lt;p&gt;And that should be it! If you are still having trouble with this, leave a comment and I can try and work through it with you.&lt;/p&gt;
</summary><category term="linux"></category><category term="hdmi"></category><category term="audio"></category></entry><entry><title>iptables - Route Traffic from Specific Interface to a Specific Gateway</title><link href="http://oldmantaiter.github.io/techlog/2009/10/iptables-route-traffic-from-specific-interface-to-a-specific-gateway.html" rel="alternate"></link><updated>2009-10-29T09:21:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2009-10-29:techlog/2009/10/iptables-route-traffic-from-specific-interface-to-a-specific-gateway.html</id><summary type="html">&lt;p&gt;Recently I set up Openfire as a corporate messaging service, the problem I ran into was that since our VPN server and Openfire server both have external access and are in the same address space, the VPN server would try to send the Openfire traffic out the external gateway but couldn't reach the server because of some ACLs that were set in place.&lt;/p&gt;
&lt;p&gt;So what I did was take the traffic from the VPN tunnel that is going to the Openfire ports and route it through our internal network.&lt;/p&gt;
&lt;p&gt;What you will need to do is create another route table and mark the desired packets with iptables.&lt;/p&gt;
&lt;p&gt;First you should pick a table number to create, I picked table #300. I made sure that the table did not exist before creating it by doing the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip route show table 300
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This shouldn't return any information, if it does you must select a new one as it already contains routing data and overwriting it will most likely cause some issues.&lt;/p&gt;
&lt;p&gt;Now that we know that the table doesn't exist, we are going to clear it anyways to make sure that it is clean.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip route flush table 300
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You may or may not get a message telling you that there was nothing to flush or it doesn't exist.&lt;/p&gt;
&lt;p&gt;Next we have to pick a number to have iptables mark the packets with. I chose the number 85 because in one of my previous posts I had used 80 to do some custom routing.&lt;/p&gt;
&lt;p&gt;To set an ip rule we need to figure out the hex value of the number above. The easiest way to do this is in a calculator that can display hex and decimal values. In GNOME you can select the calculator from Applications &amp;gt; Accessories &amp;gt; Calculator, then select View &amp;gt; Programming. To make the conversion, make sure that the &amp;quot;Dec&amp;quot; radio button is selected and type in the number you want (eg. 85). Now click the &amp;quot;Hex&amp;quot; radio button and it will give you the hex value. 85 becomes 55 so our rule will use 0x55 as the hex value. As I don't have a great understanding of hex, I am not sure if larger numbers would mean that the &amp;quot;0x&amp;quot; part preceding the hex value from the calculator would change.&lt;/p&gt;
&lt;p&gt;Now we should check to make sure that no ip rule exists for our hex value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip rule
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will show all the rules that are active, if there is an entry that has 0x55 in it, pick another number.&lt;/p&gt;
&lt;p&gt;Next, flush the rule to make it clean for us to use.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip rule del fwmark 0x55
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You will probably get a message that states &amp;quot;RTNETLINK answers: No such file or directory&amp;quot;, this is a good thing and means that it really does not exist.&lt;/p&gt;
&lt;p&gt;So now we are ready to start creating the iptables rules, I do these first but you can do them after creating the routing rules if you would like (those will follow this section).&lt;/p&gt;
&lt;p&gt;Our Openfire installation uses a custom port, but I will show this with the default ports (tcp ports 5222 and 5223). This will work for any port you would like. Our OpenVPN setup uses tun0 as the tunnel adaptor so that is the interface we wish to forward packets from.&lt;/p&gt;
&lt;p&gt;We are going to use the PREROUTING table as we need to mark the packets before they get routed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; iptables -t mangle -A PREROUTING -j MARK --set-mark &lt;span class="m"&gt;85&lt;/span&gt; -i tun0 -p tcp --dport 5222
&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; iptables -t mangle -A PREROUTING -j MARK --set-mark &lt;span class="m"&gt;85&lt;/span&gt; -i tun0 -p tcp --dport 5223
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, the --set-mark flag value is our number that we picked in a previous section. It correlates to the fwmark 0x55 rule that we will be creating (because they are equal values, just one is decimal and the other is hex).&lt;/p&gt;
&lt;p&gt;The -i flag is the interface we want iptables to mark packets from.&lt;/p&gt;
&lt;p&gt;The -p flag is for the protocol (tcp/udp) and the -dport flag is the destination port of the packets.&lt;/p&gt;
&lt;p&gt;This basically means that any traffic coming through tun0 heading for tcp port 5222 or 5223 will get marked with the number 85.&lt;/p&gt;
&lt;p&gt;So now we can set the routing rules to deal with the marked packets.&lt;/p&gt;
&lt;p&gt;First we are going to set the default route for table 300 so all our marked packets will go through there. I am going to use 192.168.0.1 as the gateway.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip route add table &lt;span class="m"&gt;300&lt;/span&gt; default via 192.168.0.1
&lt;span class="go"&gt;# Now tell the rule which table to look up&lt;/span&gt;
&lt;span class="gp"&gt;[root@tclarrltp ~]#&lt;/span&gt; ip rule add fwmark 0x55 table 300
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember that unless you make the rule persistent or have a script start on boot with these commands, the routing will not be there when you restart your machine.&lt;/p&gt;
&lt;p&gt;A simple script would look like the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/bash&lt;/span&gt;

ip route flush table 300
ip rule del fwmark 0x55
iptables -t mangle -A PREROUTING -j MARK --set-mark &lt;span class="m"&gt;85&lt;/span&gt; -i tun0 -p tcp --dport 5222
iptables -t mangle -A PREROUTING -j MARK --set-mark &lt;span class="m"&gt;85&lt;/span&gt; -i tun0 -p tcp --dport 5223
ip route add table &lt;span class="m"&gt;300&lt;/span&gt; default via 192.168.0.1
ip rule add fwmark 0x55 table 300
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have any questions, feel free to leave me a comment or send me an email.&lt;/p&gt;
</summary><category term="iptables"></category><category term="firewall"></category><category term="linux"></category></entry><entry><title>LVM Migration to smaller disk</title><link href="http://oldmantaiter.github.io/techlog/2009/10/lvm-migration-to-smaller-disk.html" rel="alternate"></link><updated>2009-10-20T11:59:00-04:00</updated><author><name>Tait Clarridge</name></author><id>tag:oldmantaiter.github.io,2009-10-20:techlog/2009/10/lvm-migration-to-smaller-disk.html</id><summary type="html">&lt;p&gt;Recently I purchased an SSD (OCZ Agility 60GB) to put into my Asus EEEPC-1000HE and wanted to migrate everything from my default 160GB drive to the new SSD. This required resizing of the LVM prior to copying the partitions across to the SSD.&lt;/p&gt;
&lt;p&gt;It is also very important that your logical volumes you wish to resize and migrate aren't filled with more data than the destination drive will hold!&lt;/p&gt;
&lt;p&gt;For example my root LV (called lv_root) had 9GB in use so it was alright for me to resize and transfer to the new system.&lt;/p&gt;
&lt;p&gt;Also, you will probably need to remove your swap LV (if your swap is configured as an LV), there will be an example of how to do that.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Required Items:&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;USB Drive or Blank CDROM&lt;/li&gt;
&lt;li&gt;liveusb-creator (if using USB method)&lt;/li&gt;
&lt;li&gt;(Optional)Fedora LiveCD Iso&lt;/li&gt;
&lt;li&gt;USB SATA II connector or secondary SATA port on your motherboard&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now you can create the LiveUSB or LiveCD of Fedora. Do this now!&lt;/p&gt;
&lt;p&gt;Have all the above items? Lets get started.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;IMPORTANT&lt;/em&gt;: You need to create a full backup of data on your drive, or at least copy the important files to a safe location. Do not forget to do this, if the LVM resizing fails you will be without all your data!&lt;/p&gt;
&lt;p&gt;So, after you backup your system you need to install the new drive.&lt;/p&gt;
&lt;p&gt;I used a USB SATA / IDE adapter that can handle both formats in 3.5&amp;quot; and 2.5&amp;quot; sizes, it can be found on TigerDirect's website here.&lt;/p&gt;
&lt;p&gt;My instructions are going to be for my EEEPC-1000HE so if you have any questions, leave a comment.&lt;/p&gt;
&lt;p&gt;My guess is that if you are using a desktop system, you will need to use the SATA connection that your original drive was using for the new one and use a secondary connection for your old hard drive.&lt;/p&gt;
&lt;p&gt;Throughout this how-to you will see &lt;strong&gt;[root&amp;#64;host ~]#&lt;/strong&gt; , this is the command prompt and yours may be different, simply enter the commands in your terminal as they appear after the prompt.&lt;/p&gt;
&lt;div class="section" id="step-one-install-the-smaller-hard-drive-in-the-eeepc"&gt;
&lt;h2&gt;Step One: Install the smaller hard drive in the EEEPC&lt;/h2&gt;
&lt;p&gt;This is a pretty straightforward step, unplug your machine and remove the battery. Open up the bottom access panel and unplug and remove the old hard drive. Remove the old hard drive from the tray and replace it with the smaller drive, now you can place it back into the machine.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-two-plug-in-the-old-hard-drive-into-the-usb-to-sata-adaptor-or-another-sata-port"&gt;
&lt;h2&gt;Step Two: Plug in the old hard drive into the USB to SATA adaptor (or another SATA port)&lt;/h2&gt;
&lt;p&gt;This is another straightforward step, since I was using a USB adapter I had to plug in the necessary cables into my drive (they were included in the adapter kit).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;IMPORTANT&lt;/em&gt;: Do not plug this into the computer yet if booting off a USB drive (required for EEEPC).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-three-boot-into-fedora-live-either-off-of-a-usb-or-cdrom-as-described-in-the-required-section"&gt;
&lt;h2&gt;Step Three: Boot into Fedora Live (either off of a USB or CDROM as described in the required section).&lt;/h2&gt;
&lt;p&gt;You may be required to set some BIOS options to allow USB booting (if using this method). In the case of my EEEPC I had to plug in the USB drive containing the Fedora Live system then access the BIOS and set the hard drive boot options to have &amp;quot;usb: removable drive&amp;quot; at the top.&lt;/p&gt;
&lt;p&gt;Now you can start up your machine and it should boot into the Live system&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-four-if-required-plug-in-the-original-hard-drive-using-the-usb-adapter-after-live-system-has-booted"&gt;
&lt;h2&gt;Step Four: (if required) Plug in the original hard drive using the USB adapter after Live system has booted&lt;/h2&gt;
&lt;p&gt;This is done after booting the system to ensure that there are no conflicts with USB devices to boot off of in the BIOS.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-five-find-the-drive-names-for-your-system-to-use-in-the-migration-process"&gt;
&lt;h2&gt;Step Five: Find the drive names for your system to use in the migration process&lt;/h2&gt;
&lt;p&gt;You will need to make sure the drives aren't mounted anywhere, this is shown below.
There are a few ways you can do this, but the easiest way is to fire up a terminal and become the superuser (root):&lt;/p&gt;
&lt;p&gt;In the terminal:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[liveuser@host ~]$&lt;/span&gt; su -
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; mount
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If there is anything that shows /dev/sdb1 (old hard drive) or your volume groups (they shouldn't be mounted in a live system), unmount them with:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; umount /dev/sdb1
&lt;span class="go"&gt;# Or for volume group&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; umount /dev/vg_yourvg-lv_yourlv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now lets list the disks&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; fdisk -l
&lt;span class="go"&gt;Disk /dev/sda: 60.0GB, xxxxxxxxxxxxx bytes&lt;/span&gt;
&lt;span class="go"&gt;xxx heads, xx sectors/track, xxxxx cylinders&lt;/span&gt;
&lt;span class="go"&gt;Units = cylinders of xxxxx * xxx = xxxxxxxx bytes&lt;/span&gt;
&lt;span class="go"&gt;Disk identifier: xxxxxxxx&lt;/span&gt;

&lt;span class="go"&gt; Disk /dev/sda doesn&amp;#39;t contain a valid partition table&lt;/span&gt;

&lt;span class="go"&gt;# (this is normal if the disk is new)&lt;/span&gt;

&lt;span class="go"&gt;Disk /dev/sdb: 160.0GB, xxxxxxxxxxxxxx bytes&lt;/span&gt;
&lt;span class="go"&gt;xxx heads, xx sectors/track, xxxxx cylinders&lt;/span&gt;
&lt;span class="go"&gt;Units = cylinders of xxxxxxx * xxx = xxxxxxxxxxxxx bytes&lt;/span&gt;
&lt;span class="go"&gt;Disk identifier: xxxxxxxxxxxx&lt;/span&gt;

&lt;span class="go"&gt;  Device  Boot   Start   End   Blocks   Id    System&lt;/span&gt;
&lt;span class="go"&gt;/dev/sdb1  *     x       xx    xxxxxx   83   Linux&lt;/span&gt;
&lt;span class="go"&gt;/dev/sdb2        xx      xxxxx xxxxxxxx 8e   Linux LVM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(It may also show a bunch of devices called /dev/dm-0, /dev/dm-1, /dev/dm-2 with messages saying &amp;quot;Disk /dev/dm-x doesn't contain a valid partition table. This is normal, just ignore these for the purposes if this post)&lt;/p&gt;
&lt;p&gt;So our values for the rest of this howto are:
&lt;strong&gt;New disk&lt;/strong&gt;: /dev/sda
&lt;strong&gt;Old disk&lt;/strong&gt;: /dev/sdb&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-six-create-partition-layout-on-new-hdd"&gt;
&lt;h2&gt;Step Six: Create partition layout on new HDD&lt;/h2&gt;
&lt;p&gt;Since we now have the drive names, we can go ahead and partition the new disk to have the two partitions (your disk setup might be different, mine had /boot on the first partition and the LVM on the second partition).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt; from the future: I'm showing fdisk here, but you can do the same thing with any partition editing (I prefer parted these days)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; fdisk /dev/sda

&lt;span class="go"&gt;Command (m for help): o&lt;/span&gt;
&lt;span class="go"&gt;Building a new DOS disklabel with disk identifier xxxxxxxxxxxx&lt;/span&gt;
&lt;span class="go"&gt;Changes will remain in memory only, until you decide to write them.&lt;/span&gt;
&lt;span class="go"&gt;After that, of course, the previous content won&amp;#39;t be recoverable.&lt;/span&gt;

&lt;span class="go"&gt;### If you get a warning about invalid flags, those are OK too.&lt;/span&gt;

&lt;span class="go"&gt;Command (m for help): n&lt;/span&gt;
&lt;span class="go"&gt;Command action&lt;/span&gt;
&lt;span class="go"&gt;  e   extended&lt;/span&gt;
&lt;span class="go"&gt;  p   primary partition (1-4)&lt;/span&gt;
&lt;span class="go"&gt;p (this is my input)&lt;/span&gt;
&lt;span class="go"&gt;Partition number (1-4): 1&lt;/span&gt;
&lt;span class="go"&gt;First cylinder (1-xxxx, default 1): 1&lt;/span&gt;
&lt;span class="go"&gt;### I chose 250 MB for extra kernel installs/preupgrade&lt;/span&gt;
&lt;span class="go"&gt;Last cylinder, +cylinders or +size{K,M,G} (1-xxx, default xxx): +250M&lt;/span&gt;

&lt;span class="go"&gt;Command (m for help): n&lt;/span&gt;
&lt;span class="go"&gt;Command action&lt;/span&gt;
&lt;span class="go"&gt;   e    extended&lt;/span&gt;
&lt;span class="go"&gt;   p    primary partition (1-4)&lt;/span&gt;
&lt;span class="go"&gt;p&lt;/span&gt;
&lt;span class="go"&gt;Partition number (1-4): 2&lt;/span&gt;
&lt;span class="go"&gt;### Pressing enter through these should make it the rest of the disk&lt;/span&gt;
&lt;span class="go"&gt;First cylinder (xx-xxxx, default xxx): &amp;lt;press enter&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;Using default value xxx&lt;/span&gt;
&lt;span class="go"&gt;Last cylinder, +cylinders or +size{K,M,G} (xx-xxxx, default xxxx): &amp;lt;press enter&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;Using default value xxxx&lt;/span&gt;

&lt;span class="go"&gt;Command (m for help): t&lt;/span&gt;
&lt;span class="go"&gt;Partition number (1-4): 2&lt;/span&gt;
&lt;span class="go"&gt;Hex code (type L to list codes): 8e&lt;/span&gt;
&lt;span class="go"&gt;Changed system partition 2 to 8e (Linux LVM)&lt;/span&gt;

&lt;span class="go"&gt;Command (m for help): w&lt;/span&gt;
&lt;span class="go"&gt;The partition table has been altered!&lt;/span&gt;

&lt;span class="go"&gt;Calling ioctl() to re-read partition table.&lt;/span&gt;
&lt;span class="go"&gt;Syncing disks.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Your partitions are now ready for some data!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-seven-copy-the-boot-partition-from-the-old-drive-to-the-new-drive-and-resize-it"&gt;
&lt;h2&gt;Step Seven: Copy the boot partition from the old drive to the new drive and resize it&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; e2fsck -f /dev/sdb1
&lt;span class="go"&gt;&amp;lt;Output of e2fsck snipped&amp;gt;&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/sdb1 &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/sda1
&lt;span class="go"&gt;&amp;lt;Output of dd snipped&amp;gt;&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; e2fsck -f /dev/sda1
&lt;span class="go"&gt;&amp;lt;Output of e2fsck snipped&amp;gt;&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; resize2fs /dev/sda1
&lt;span class="go"&gt;&amp;lt;Output of resize2fs snipped&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The resize2fs output should say that it successfully resized the filesystem to a certain amount of blocks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-eight-gather-information-on-your-lvm-structure"&gt;
&lt;h2&gt;Step Eight: Gather information on your LVM structure&lt;/h2&gt;
&lt;p&gt;For this step, you need to make note of what your logical volumes, volume groups, and physical volumes are called.&lt;/p&gt;
&lt;p&gt;In this how to mine are as follows:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;strong&gt;Root&lt;/strong&gt;: lv_root&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Swap&lt;/strong&gt;: lv_swap&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Volume Group&lt;/strong&gt;: vg_taitsstuff&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The columns shown below are the only ones you should be concerned with.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvs
&lt;span class="go"&gt;LV            VG                  LSize&lt;/span&gt;
&lt;span class="go"&gt;lv_root     vg_taitsstuff      144.xxG&lt;/span&gt;
&lt;span class="go"&gt;lv_swap     vg_taitsstuff      4.xG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So this shows my current logical volume setup where:&lt;/p&gt;
&lt;p&gt;lv_root is located on vg_taitsstuff and is 144.xxG in size
lv_swap is located on vg_taitstuff and is 4.xG in size&lt;/p&gt;
&lt;p&gt;Now we can look at the information for the volume groups:&lt;/p&gt;
&lt;p&gt;The columns that have been omitted are unimportant at this point.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; vgs
&lt;span class="go"&gt;VG              #PV  #LV  #SN  VSize VFree&lt;/span&gt;
&lt;span class="go"&gt;vg_taitsstuff  1        2      0    148.xxG   0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that:&lt;/p&gt;
&lt;p&gt;vg_taitstuff is 148.xxG in size with no free space located on ONE physical volume and contains TWO logical volumes.&lt;/p&gt;
&lt;p&gt;So finally lets take a look at the physical volumes:
Again, the omitted columns aren't important to us right now.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; pvs
&lt;span class="go"&gt;PV             VG               PSize    PFree&lt;/span&gt;
&lt;span class="go"&gt;/dev/sdb2  vg_taitsstuff   148.xxG    0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So this means that the only LVM physical volume I have is on /dev/sdb2  and is the same size as the volume group (since it is the only one there).&lt;/p&gt;
&lt;p&gt;The things you need to remember are:
The name of the swap logical volume (mine: lv_swap)
The name of the physical volume (mine: /dev/sdb2)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-nine-remove-swap-logical-volume"&gt;
&lt;h2&gt;Step Nine: Remove SWAP logical volume&lt;/h2&gt;
&lt;p&gt;I was having issues with resizing due to the placement of my SWAP logical volume, so what I did was remove it (it will be recreated later with the information from the above section).&lt;/p&gt;
&lt;p&gt;So, lets turn the swap off and remove it:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; swapoff -v /dev/vg_taitsstuff/lv_swap
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvremove /dev/vg_taitsstuff/lv_swap
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-ten-resize-root-logical-volume"&gt;
&lt;h2&gt;Step Ten: Resize ROOT logical volume&lt;/h2&gt;
&lt;p&gt;Since I have only one logical volume for my system (other than the swap we just deleted) this is relatively straightforward, if you have multiple partitions I am not able to help you at the moment.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; e2fsck -f /dev/vg_taitsstuff/lv_root
&lt;span class="go"&gt;# 50G was chosen so it was smaller than the size of the HDD, noobish I know.&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; resize2fs -p /dev/vg_taittstuff/lv_root 50G
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvreduce --size 50G vg_taitsstuff/lv_root --test
&lt;span class="go"&gt;# If there were any errors in the test, do not issue the next command&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvreduce --size 50G vg_taitsstuff/lv_root
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-eleven-resize-the-physical-volume"&gt;
&lt;h2&gt;Step Eleven: Resize the physical volume&lt;/h2&gt;
&lt;p&gt;Now we can resize the volume so it will fit in our new partition on the new disk.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; pvresize --setphysicalvolumesize 55G /dev/sdb2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should complete successfully. The reason why I chose 55G was that it was greater than the filesystem size we set in Step 10 and less than the new hard drive size (60 GB)&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-twelve-copy-the-old-partition-to-the-new-drive"&gt;
&lt;h2&gt;Step Twelve: Copy the old partition to the new drive&lt;/h2&gt;
&lt;p&gt;Some people may argue that I am taking a round about way to do this, I did it this way because it made sense at the time. I tried migrating the volume groups without success so I did it this way.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/sdb2 &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/dev/sda2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will take a while depending on the size, also it may tell you that it ran out of space, this should be alright because it will already be finished writing the physical volume that we resized in the previous step.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="step-thirteen-physically-disconnect-the-old-drive"&gt;
&lt;h2&gt;Step Thirteen: Physically disconnect the old drive&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="step-fourteen-resize-the-pv-on-the-new-drive"&gt;
&lt;h2&gt;Step Fourteen: Resize the PV on the new drive&lt;/h2&gt;
&lt;p&gt;This step is so we can get full use of our LVM partition.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; pvresize /dev/sda2
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-fifteen-resize-the-logical-volume-and-filesystem-on-the-new-drive-and-create-the-new-swap-logical-volume"&gt;
&lt;h2&gt;Step Fifteen: Resize the logical volume and filesystem on the new drive and create the new swap logical volume&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvextend /dev/vg_taitsstuff/lv_root /dev/sda2
&lt;span class="go"&gt;# 4GB here is the size of the swap partition I want&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvreduce --size -4G vg_taitsstuff/lv_root
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; lvcreate --name lv_swap vg_taitsstuff
&lt;span class="go"&gt;# There are a lot of these filesystem checks, some may say too many, but lets be safe&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; e2fsck -f /dev/vg_taitsstuff/lv_root
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; resize2fs /dev/vg_taitsstuff/lv_root
&lt;span class="go"&gt;# Lets bring back that swap LV&lt;/span&gt;
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; mkswap /dev/vg_taitsstuff/lv_swap
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-seventeen-reinstall-grub-on-the-new-drive"&gt;
&lt;h2&gt;Step Seventeen: Reinstall GRUB on the new drive&lt;/h2&gt;
&lt;p&gt;We need to activate the vg, mount the partitions, and reinstall grub.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; mkdir -p /mnt/temp/boot
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; vgchange -a y
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; mount /dev/sda1 /mnt/temp/boot
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; mount /dev/vg_taitsstuff/lv_root /mnt/temp
&lt;span class="gp"&gt;[root@host ~]#&lt;/span&gt; grub-install --root-directory&lt;span class="o"&gt;=&lt;/span&gt;/mnt/temp /dev/sda
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="step-eighteen-reboot"&gt;
&lt;h2&gt;Step Eighteen: Reboot&lt;/h2&gt;
&lt;p&gt;Now that everything has reinstalled and been resized, it is time for a reboot! If your grub menu is just a prompt, not to worry.&lt;/p&gt;
&lt;p&gt;Just enter the following commands in the grub prompt (grub&amp;gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="go"&gt;grub&amp;gt; kernel /vmlinuz-2.6.rest.of.your.kernel.version&lt;/span&gt;
&lt;span class="go"&gt;grub&amp;gt; initrd /initrd-2.6.same.as.above&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you do not know the kernel version off hand, you can press tab twice after entering kernel and a forward slash and it will show the available versions. The same goes for the ramdisk (initrd), just make sure that the ramdisk version and the kernel version are the same.&lt;/p&gt;
&lt;p&gt;Once you login to your system just run &amp;quot;grub-install /dev/sda&amp;quot; as root and things should be back to normal.&lt;/p&gt;
&lt;p&gt;Remember. MAKE SURE YOU HAVE BACKED UP EVERYTHING. My instructions may not work for your setup so you should have a full backup (I did a &amp;quot;dd&amp;quot; of my entire disk to a file before I started resizing to an external hard drive while booted from a Live USB).&lt;/p&gt;
&lt;/div&gt;
</summary><category term="lvm"></category><category term="linux"></category></entry></feed>